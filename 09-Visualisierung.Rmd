---
output: html_document
editor_options: 
  chunk_output_type: console
---
# (PART) Der Spaßige Teil {-}

```{r load_fonts, include=FALSE}
# Fancy font stuff required for hrbrthemes
library(extrafont)
loadfonts()
```


# Visualisierung

Es hat ein bisschen gedauert, aber wir mussten uns zuerst erarbeiten, wie wir eigentlich in R mit Daten umgehen können und grob verstehen wie sich R überhaupt verhält, bis wir endlich was spaßiges machen können.  
Und Datenvisualisierung ist vermutlich so ziemlich das spaßigste, was wir in R anstellen können. Eine gute Visualisierung (*Plot*) ist aussagekräftigter als jede schnöde Tabelle, kann unintuitive Zusammenhänge aufdecken und die Interpretation eurer Daten deutlich vereinfachen.  
Deswegen ist der erste Schritt jeder Datenanalyse ein Plot der Daten in verschiedenen Formen um ein Gefühl für die Struktur und die Zusammenhänge dieser Daten zu bekommen.

## ggplot2

[ggplot2](http://had.co.nz/ggplot2/) ist nicht nur ein R-Packages, es ist auch gleichzeitig eine Implementation des *Grammar of Graphics*. Das klingt fancy (ist es auch), heißt für uns aber in erster Linie nur, dass es gut durchdachter Kram ist. 

```{r}
library(ggplot2)
```


## `geom_wtf`

Der visuelle Kern eines Plots ist die geometrische Verknüpfung eurer Daten auf einen *Layer*, sowas wie Punkte, Linien, Balken, ihr wisst schon. Ein Plot braucht mindestens einen *Layer* (ein *geom*) um überhaupt irgendwas anzuzeigen, und die entsprechenden Funktionen sind dankbar einfach benannt:

- `geom_point`: Macht Punkte (*Scatterplot*)
- `geom_line`: Macht Linien
- `geom_boxplot`: Boxplots
- `geom_histogram`: Histogramm (Häufigkeitsverteilung)
- `geom_bar`: Balkendiagramm mit Häufigkeiten auf der y-Achse
- `geom_col`: Balkendiagramm mit frei wählbarer y-Achse

### Barcharts & Histogramme

Eine der einfachsten Anwendungsfälle für Visualisierungen sind Balken- und Histogramme. Der Unterschied zwischen den beiden ist eher subtil: Histogramme haben eine numerische/kontinuierliche Variable auf der x-Achse, und Barcharts haben diskrete Variablen auf der x-Achse. Daraus ergibt sich auch, dass Barcharts immer einen Balken pro Merkmalsausprägung haben.  
Die y-Achse ist jeweils die Häufigkeit, mit der die jeweilige Variable auftritt. Diese wird in der Regel als absolute Häufigkeit in ggplot2 angezeigt, aber wir können auch relative Häufigkeiten oder *densities* verwenden.

```{r barchart}
# Balkendiagramm
ggplot(data = gotdeaths, aes(x = death_season)) +
  geom_bar()

# Balken mit relativen Häufigkeiten
ggplot(data = gotdeaths, aes(x = death_season)) +
  geom_bar(aes(y = ..prop..))
```

Das ist zwar schön und gut, aber es sieht noch nicht so wirklich brauchbar aus, und es fehlen vor allem aussagekräftige Beschriftungen. Letztere sind via `labs()` sehr einfach:

```{r}
ggplot(data = gotdeaths, aes(x = death_season)) +
  geom_bar() +
  labs(title = "Game of Thrones: Deaths",
       subtitle = "Deaths per Season",
       x = "Season", y = "# of Deaths")
```


## Mach mal bunt!

Okay, wir wollen also die Balken bunt machen. Es gibt zwei Möglichkeiten: Die `color` und `fill`. Ersteres ist die Farbe (duh), zweiteres die Füllfarbe (duhuh), und unterschiedliche `geoms` haben da entsprechende Unterschiede.

```{r}
ggplot(data = gotdeaths, aes(x = death_season)) +
  geom_bar(color = "red") +
  labs(title = "Game of Thrones: Deaths",
       subtitle = "Deaths per Season",
       x = "Season", y = "# of Deaths")
```

Jetzt haben wir rote Umrandungen. Nicht sehr beeindruckend.

```{r}
ggplot(data = gotdeaths, aes(x = death_season)) +
  geom_bar(fill = "red") +
  labs(title = "Game of Thrones: Deaths",
       subtitle = "Deaths per Season",
       x = "Season", y = "# of Deaths")
```

Ein bisschen grell, aber immerhin rot.

```{r}
ggplot(data = gotdeaths, aes(x = death_season)) +
  geom_bar(fill = "darkred", color = "black") +
  labs(title = "Game of Thrones: Deaths",
       subtitle = "Deaths per Season",
       x = "Season", y = "# of Deaths")
```

Okay, vielleicht ein bisschen Transparenz noch?

```{r}
ggplot(data = gotdeaths, aes(x = death_season)) +
  geom_bar(fill = "darkred", color = "black", alpha = 0.75) +
  labs(title = "Game of Thrones: Deaths",
       subtitle = "Deaths per Season",
       x = "Season", y = "# of Deaths")
```

`alpha` gibt die Durchsichtigkeit des Elements an, von `0` (unsichtbar) bis `1` (keine Transparenz).  
Was die Farben angeht: R kennt `red` und `darkred` neben etlichen anderen Farben.  Diese Farben könnt ihr euch via `colors()` ausgeben lassen — also zumindest die Namen der Farben.  
Alternativ könnt ihr Farben auch als Hex-String angeben, rot wäre dann zum Beispiel `#FF0000`. Wenn ihr mal "rgb color picker" googlet, findet ihr auch entsprechende tools, oder ihr installiert das `colorpicker` package und habt dann sowas direkt in RStudio unter "Addins":

```{r, echo=FALSE, out.width="75%", fig.cap="cap"}
knitr::include_graphics("images/colorpicker.png")
```


### `scale_color_*` und `scale_fill_*`

Wenn wir global die Farbe der Balken ändern wollen, können wir das direkt simpel im `geom_bar()`-Element machen, aber manchmal wollen wir ja auch die Farbe abhängig von einer anderen Variable machen.  

Wenn wir einer *aesthetic* wie `fill` oder `color` eine Variable zuordnen wollen, müssen wir das in `aes()` tun, wo wir auch `x` und `y` definieren. 

```{r}
ggplot(data = qmsurvey, aes(x = rauchen)) +
  geom_bar()
```

```{r}
ggplot(data = qmsurvey, aes(x = rauchen, fill = gender)) +
  geom_bar()
```

```{r}
ggplot(data = qmsurvey, aes(x = rauchen, fill = gender)) +
  geom_bar(position = "dodge", color = "black", alpha = .75)
```

### Zusätzliche Farbpaletten

#### RColorBrewer

```{r}
# install.packages(RColorBrewer)

ggplot(data = qmsurvey, aes(x = rauchen, fill = gender)) +
  geom_bar(position = "dodge", color = "black", alpha = .75) +
  scale_fill_brewer(palette = "Set1")
```

Übersicht über die Farbpaletten:

```r
library(RColorBrewer)

display.brewer.all()
```

```{r, echo=FALSE, out.width="75%", fig.cap="RColorBrewer Paletten"}
knitr::include_graphics("images/brewer_palettes.png")
```


#### Viridis

Besondere Stärke: Gleicher wahrgenommener Abstand der Farben, demnach besonders gut geeignet für kontinuierliche Fabrskalen. Bonus: Auch noch gut distinguierbar, wenn in schwarzweiß konvertiert.

```{r}
library(viridis)

ggplot(data = qmsurvey, aes(x = rauchen, fill = gender)) +
  geom_bar(position = "dodge", color = "black", alpha = .75) +
  scale_fill_viridis(discrete = TRUE, option = "plasma")
```


### Themes

Themes verändern nicht die Farbe eurer Punkte/Linien/Balken, aber sie verändern alles andere an eurem Plot, von der Hintergrundfarbe bis zur Schriftart in den Labels.  
Es gibt viele schöne themes, aber der allgemeine Ratschlag bleibt: Simpel ist besser.  

```{r}
plot <- ggplot(data = gotdeaths, aes(x = death_season)) +
  geom_bar() +
  labs(title = "Game of Thrones: Deaths",
       subtitle = "Deaths per Season",
       x = "Season", y = "# of Deaths")
```


```{r}
library(tadaatoolbox)

plot + theme_tadaa()
```

Oder auch:

```{r}
library(hrbrthemes)

plot + theme_ipsum()
```

Siehe auch: `ggthemes`

```{r}
library(ggthemes)

plot + theme_gdocs()
plot + theme_pander()
plot + theme_fivethirtyeight()
plot + theme_excel() # Nein.
plot + theme_economist()
```
