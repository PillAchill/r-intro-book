# Datentypen

Es gibt eine Reihe von Unterscheidungsmöglichkeiten zwischen verschiedenen Arten von Daten.  
Neben der naheliegenden Unterscheidung zwischen "Zahlen" und "Buchstaben" gibt es diverse andere Typen, die R verwendet.  
Technisch gesehen müssten wir hier noch zwischen Typen und Klassen unterscheiden, aber für die meisten unserer normalen Anwendungszwecke ist es nicht unbedingt notwendig Typen und Klassen auseinanderhalten zu können, weshalb wir hier auch mehr oder weniger beides gleichzeitig abhandeln.

*"Und wieso sollte uns interessieren, wie R da unterscheidet?"*  
R ist verwirrt, wenn wir Buchstaben in eine Funktion stecken, die Zahlen erwartet. Genauso ist R verwirrt, wenn wir den Mittelwert aus einer Tabelle berechnen wollen. Mittelwerte sind nur dann sinnvoll, wenn wir sie aus einem Vektor aus numerischen Werten berechnen. Da eure Daten in verschiedenen Formaten ankommen, und unterschiedliche Repräsentationen unterschiedliche Vor- und Nachteile haben, ist es wichtig, dass ihr im Zweifelsfall herausfinden könnt was ihr da vor der Nase habt und wie ihr damit arbeiten könnt.  
Was eine R-Funktion mit einem Objekt anstellt hängt von der *Klasse* des Objekts ab, das ganze fällt vermutlich irgendwo unter *"object oriented programming"*, und wenn ihr InformatikerInnen kennt und die euch Fragen, ob R eine funktionale oder objektorientierte Frage ist, könnt ihr getrost "ja" sagen[^logic].

Die wichtigste Funktion für diesen Abschnitt ist `class()`, was euch sagt was R unter einem bestimmten Objekt versteht (die *Klasse* des Objekts):

```{r}
class(4)
class(c(1, 2, 3))
class(c("hallo", "welt"))
class(sleep)
class(sleep$extra)
class(sleep$group)
```

<small>(Was es mit `factor` auf sich hat sehen wir ein paar Abschnitte weiter)</small>

Zusätzlich gibt es `typeof()`, eine Funktion, die so speziell ist, dass ich sie in meinen ~4 Jahren R erst neulich entdeckt habe, weil der exakte *Typ* eines Objekts meistens weniger relevant ist als die *Klasse*:

```{r}
typeof(4)
typeof(c(1, 2, 3))
typeof(c("hallo", "welt"))
typeof(sleep)
typeof(sleep$extra)
typeof(sleep$group)
```

## Numeric <small class="subtitle">(Zahlen und so)</small>

Zahlen in R (und in den meisten anderen Programmiersprachen, beziehungsweise generell irgendwo, wo Maschinen rechnen) kommen in zwei Geschmacksrichtungen: **Integer** (ganze Zahlen) und **double** (Dezimalzahlen, Fließkommazahlen, *floating point numbers*).  
Der Grund dafür hat damit zu tun, wie Computer intern Zahlen abbilden, binäres Zahlensystem, Bits, ihr wisst schon — komplizierter Kram wo sich kluge Menschen Dinge ausdachten, mit denen wir arbeiten können, wir aber nicht im Detail verstehen müssen.  
Fließkommazahlen sind so gängig, dass R sogar eine einfache ganze Zahl wie `2` erstmal als *double*, also praktisch als `2.0` interpretiert, und wir explizit `2L` schreiben müssen, wenn wir *"2, aber als integer"* meinen. Wieso wir dafür `L` brauchen sei dahingestellt, aber nun ja, der Unterschied ist da:

```{r}
# Beides "numeric"
class(2)
class(2.5)

# Aber…
typeof(2L)

# …und
typeof(2.5)
```


Integers sind ziemlich unproblematisch, werden aber in der Praxis nicht häufig explizit genutzt.  
Fließkommazahlen (*double*) hingegen tauchen häufiger auf, weil Computer in den letzten Jahrzehnten *echt verdammt gut* darin geworden sind, mit Fließkommazhalen zu rechnen. Arithmetik mit integers ist auch okay, aber wenn eure Datensätze riesig und eure Statistik komplex ist, dann ist Geschwindigkeit von Rechenoperationen auf ein mal ein wichtiger Faktor.  
Das Problem an der Sache ist nur leider, dass Fließkommazahlen seltsam sind. Nicht nur vom initialen Verständnis her, dazu empfehle ich euch herzlichst [dieses schöne Video von Tom Scott](https://www.youtube.com/watch?v=PZRI1IfStY0), sondern auch für ganz reale Konsequenzen, über die wir stolpern können, wenn wir nicht aufpassen:

```{r}
# Wurzel aus 2, ganz harmlos
sqrt(2)

# Quadrierte Wurzel aus 2 ergibt 2, ja, kommt hin
sqrt(2)^2

# Das sollte ja dann…
sqrt(2)^2 == 2
```

<small>Wait, what?</small> 

Und das ist der Grund warum Fließkommazahlen (*double*) seltsam sind.  
Die kurze Version: $\sqrt{2}$ ist eine *irrationale Zahl*, das heißt sie hat *unendlich viele Nachkommastellen*. Computer können nur eine begrenzte Anzahl an Nachkommastellen speichern, weshalb das Resultat von einer Berechnung wie $\left(\sqrt{2}\right)^2$ zwar für alle praktischen Zwecke immer noch 2 ist, aber *irgendwie auch nicht*. Wenn wir mit Datensätzen arbeiten und darin rumrechnen dann sind solche kleinen Rundungsfehler egal, aber wenn wir uns auf Operatoren wie `==` verlassen, um berechnete Werte zu vergleichen, dann müssen wir vorsichtig sein.  

An dieser Stelle ein kurzer Exkurs in die Numerik:  
Die absolut kleinste Toleranz, die euer Computer für Fließkommazahlen berücksichtigt, könnt ihr euch mit `.Machine$double.eps` anzeigen lassen[^bits]. `.Machine` ist ein besonderes Objekt in R, dass Informationen zu eurem Computer (sprich eurer *Maschine*) sammelt.  

```{r}
# Wie groß ist die Abweichung vom erwarteten Ergebnis?
sqrt(2)^2 - 2
```

`4.4408920985e-16` ist Computer für $4.4408920985 \cdot 10^{-16}$, also ungefähr…

$$\frac{4.4408920985}{10000000000000000} \approx 0.00000000000000044$$

Das ist… ziemlich wenig, und im Alltag auch ziemlich egal, aber wie gesagt: Für R ist das ein Unterschied.

```{r}
# Wie groß ist die Toleranz?
.Machine$double.eps

# Moment mal…
.Machine$double.eps * 2

# Wenn jetzt…
(.Machine$double.eps * 2) == (sqrt(2)^2 - 2)
```

Tatsache.  
Wir könnten noch weiter damit rumspielen, aber als Lektion sollte eigentlich nur hängenbleiben, dass Zahlen in R gerne mal mehr sind, als euch in der Konsole angezeigt wird.

```{block2, float-rounding, type='rmdimportant'}
> One does not simply *round* floating point numbers
> --- [Programmer Boromir](https://ironholds.org/projects/rbitrary/#why-doesnt-round-work-like-you-think-it-should)

```

Wenn ihr mal auf sowas stoßen solltet, dann verwendet am besten einfach die Funktion `round()` um eure Werte auf eine sinnvolle Anzahl Nachkommastellen zu runden:

```{r}
# Auf 5 Stellen gerundete Wurzel 2
round(sqrt(2), digits = 5)

# Gerundetes Ergebnis von "Wurzel 2 hoch 2"
round(sqrt(2)^2, digits = 5)

# Literally close enough.
round(sqrt(2)^2, digits = 5) == 2
```

```{block2, float-rounding_tip, type='rmdtip'}
Im Zweifelsfall einfach Genauigkeit Opfern um den Verstand zu behalten
```

Theoretisch ist "numeric" für Zahlen eine *Klasse*, und *integer* und *double* sind die beiden *Typen*, aus denen die Klasse besteht.

## Character <small class="subtitle">(Buchstabenzeugs)</small>

## Factor <small class="subtitle">(Here be dragons)</small>

## Besondere Typen

### Fehlende Werte: `NA`

### Leere Werte: `NULL`

### To `Inf` and Beyo`NaN`d!

## Tabellen <small class="subtitle">(Just a bunch of vectors)</small>

## Prüfen & Konvertieren

- `as.numeric`
- `as.character`

```{r}
# Römische Zahlen
as.roman(2017)

# Hexadezimal
as.hexmode(255)

# Logische Werte
as.logical(0)
as.logical(1)
```


<!-- Footnotes -->

[^bits]: Habt ihr mal im Kontext von Computern oder Betriebssystemen/Software von "32bit" und "64bit" gehört? Da geht's tatsächlich genau um dieses Ding mit den Fließkommazahlen. 64 bit kann einfach mehr Nachkommastellen speichern als 32bit. Vergleiche dazu auch `.Machine$double.digits` auf einem 32bit gegen ein 64bit-Betriebssystem

[^logic]: Das ist einer von diesesn Logikwitzen basierend auf dem Umstand, dass das logische *oder* (`a | b`) auch *wahr* ist, sowohl `a` als auch `b` *wahr* ist.
